<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Experience &amp; Practice on Wondrous WindomCard&#39;s Blog</title>
    <link>https://wondrouswisdomcard.gitee.io/categories/experience-practice/</link>
    <description>Recent content in Experience &amp; Practice on Wondrous WindomCard&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This is a customized copyright.</copyright>
    <lastBuildDate>Sun, 03 Jan 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wondrouswisdomcard.gitee.io/categories/experience-practice/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction of Hot Areas And Marketing Methods on Interet</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog10/</link>
      <pubDate>Sun, 03 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog10/</guid>
      <description>互联网时代的热点领域选择、营销方法 在互联网时代的浪潮下，万物皆可互联网+，区块链，人工智能，大数据成为互联网时代的热点领域，与此同时，在互联网时代的背景下，新的营销方法如雨后春笋般被提出，应用，造就新的品牌，本篇博客着眼几个互联网时代的热点领域和营销方法，作简要的介绍。
热点领域 区块链技术 所谓区块链技术，简称BT(Blockchain technology)，也被称之为分布式账本技术，是一种互联网数据库技术，其特点是去中心化、公开透明，让每个人均可参与数据库记录。最早是比特币的基础技术，目前世界各地均在研究，可广泛应用于金融等各领域。
区块链技术就像互联网一样，它具有内置的稳健性。通过存储在其网络中相同的信息块，区块链不能: 1、受任何单一实体控制。2、没有单点故障。
区块链技术具有的不可篡改、可以追溯等特点，可以和物联网技术具有的连接随手可及、计算无处不在等特点结合起来，借助物联网，在某一产品单元生产完成后，可以生成该产品的关键信息，比如生产设备加工该产品时采用的工艺数据，测试设备对该产品进行质检后得到的量测数据，这些数据打包成消息（比如JSON格式）。
引用自知乎 https://zhuanlan.zhihu.com/p/338784867
大数据 大数据（big data），指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。 在维克托·迈尔-舍恩伯格及肯尼斯·库克耶编写的《大数据时代》中大数据指不用随机分析法（抽样调查）这样捷径，而采用所有数据进行分析处理。大数据的5V特点（IBM提出）：Volume（大量）、Velocity（高速）、Variety（多样）、Value（低价值密度）、Veracity（真实性）。
转载自知乎 https://www.zhihu.com/topic/19740929/intro
人工智能 人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。 人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。人工智能从诞生以来，理论和技术日益成熟，应用领域也不断扩大，可以设想，未来人工智能带来的科技产品，将会是人类智慧的“容器”。人工智能可以对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样思考、也可能超过人的智能。 人工智能是一门极富挑战性的科学，从事这项工作的人必须懂得计算机知识，心理学和哲学。人工智能是包括十分广泛的科学，它由不同的领域组成，如机器学习，计算机视觉等等，总的说来，人工智能研究的一个主要目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作。
源自百度百科 https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/9180
工作流技术 工作流就是“业务过程的部分或整体在计算机应用环境下的自动化”，它主要解决的是“使在多个参与者之间按照某种预定义的规则传递文档、信息或任务的过程自动进行，从而实现某个预期的业务目标，或者促使此目标的实现”。
工作流系统，实现了工作流程的自动化，提高了企业运营效率，改善企业资源利用，提高企业运作的灵活性和适应性，提高量化考核业务处理的效率，减少浪费。 在java领域中，JBPM和Actvity是两个主流的工作流系统，而Flowable的出现无疑将会取代两个主流的工作流系统。
摘自博客 https://blog.csdn.net/weixin_42809672/article/details/82503011
云计算 云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒钟）完成对数以万计的数据的处理，从而达到强大的网络服务。 现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。
摘自百度百科 https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353
量子计算 量子计算是一种遵循量子力学规律调控量子信息单元进行计算的新型计算模式。对照于传统的通用计算机，其理论模型是通用图灵机；通用的量子计算机，其理论模型是用量子力学规律重新诠释的通用图灵机。从可计算的问题来看，量子计算机只能解决传统计算机所能解决的问题，但是从计算的效率上，由于量子力学叠加性的存在，某些已知的量子算法在处理问题时速度要快于传统的通用计算机。
摘自百度百科 https://baike.baidu.com/item/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/11035661?fr=aladdin
营销方法 O2O经济 O2O，是Online To Offline的缩写即在线离线/线上到线下，是指将线下的商务机会与互联网结合，让互联网成为线下交易的平台，这个概念最早来源于美国。O2O的概念非常广泛，既可涉及到线上，又可涉及到线下,可以通称为O2O。主流商业管理课程均对O2O这种新型的商业模式有所介绍及关注。
O2O营销模式又称离线商务模式，是指线上营销线上购买带动线下经营和线下消费。O2O通过打折、提供信息、服务预订等方式，把线下商店的消息推送给互联网用户，从而将他们转换为自己的线下客户，这就特别适合必须到店消费的商品和服务，比如餐饮、健身、看电影和演出、美容美发、摄影等。 实现O2O营销模式的核心是在线支付。
和O2O类似的还有B2B（也有写成 BTB，是Business-to-Business的缩写）是指企业与企业之间通过专用网络或Internet，进行数据信息的交换、传递，开展交易活动的商业模式。它将企业内部网和企业的产品及服务，通过 B2B 网站或移动客户端与客户紧密结合起来，通过网络的快速反应，为客户提供更好的服务，从而促进企业的业务发展。
·参考百度百科 O2O O2O营销模式 B2B
小米的饥饿营销 “饥饿营销”，运用于商品或服务的商业推广，是指商品提供者有意调低产量，以期达到调控供求关系、制造供不应求“假象”、以维护产品形象并维持商品较高售价和利润率的营销策略。
·参考 https://new.qq.com/omn/20200510/20200510A0IMJQ00.html
·参考知乎 https://zhuanlan.zhihu.com/p/31692491
微软的软件捆绑 案例： 微软向企业发布365软件包：捆绑销售Windows和Office
·参考网页 http://tech.sina.com.cn/roll/2017-07-11/doc-ifyhvyie0996429.shtml
·参考简书 https://www.jianshu.com/p/0af0740c96b2</description>
    </item>
    
    <item>
      <title>C - Smart Greedy Snake</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog9/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog9/</guid>
      <description>字符游戏 - 智能蛇 文档和程序地址：
https://gitee.com/WondrousWisdomcard/WondrousWisdomcard/tree/master/code/blog9
 编写智能算法 编写人工智能程序，使得 snake 每秒自动走一步。
1、程序要求说明 初始化字符矩阵中有一些你设定的障碍物（墙），并且保证非满地图中永远有且仅有一个食物。
决定蛇行走的方向的算法如下：
char whereGoNext(int Hx, int Hy, int Fx, int Fy){char movable[4] = {&#39;A&#39;,&#39;D&#39;,&#39;W&#39;,&#39;S&#39;}; //记录可走的方向int distance[4] = {INF,INF,INF,INF}; //记录离食物的距离if(map[Hy][Hx-1] == BLANK_CELL || map[Hy][Hx-1] == SNAKE_FOOD){ //Adistance[0] = abs(Fx - (Hx-1)) + abs(Fy - Hy);}if(map[Hy][Hx+1] == BLANK_CELL || map[Hy][Hx+1] == SNAKE_FOOD){ //Ddistance[1] = abs(Fx - (Hx+1)) + abs(Fy - Hy);}if(map[Hy-1][Hx] == BLANK_CELL || map[Hy-1][Hx] == SNAKE_FOOD){ //Wdistance[2] = abs(Fx - Hx) + abs(Fy - (Hy-1));}if(map[Hy+1][Hx] == BLANK_CELL || map[Hy+1][Hx] == SNAKE_FOOD){ //Sdistance[3] = abs(Fx - Hx) + abs(Fy - (Hy+1));}int i, min = INF,j = INF; // j为最后决策方向的编号for(int i = 0; i &amp;lt; 4; i++){//printf(&amp;quot;%d\n&amp;quot;,distance[i]);if(distance[i] &amp;lt; min){min = distance[i];j = i;}}if(j !</description>
    </item>
    
    <item>
      <title>C - Greedy Snake</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog8/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog8/</guid>
      <description>字符游戏 - 贪吃蛇 文档和程序地址：
https://gitee.com/WondrousWisdomcard/WondrousWisdomcard/tree/master/code/blog8
 </description>
    </item>
    
    <item>
      <title>Ethics&amp;Morality on IT</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog7/</link>
      <pubDate>Sat, 28 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog7/</guid>
      <description>IT伦理与道德讨论：流氓软件与垃圾广告 在互联网快速发展的今天，我们享受着互联网和软件给我们的服务与便利，而与此同时，提供软件的开发商为了利润向我们发送花样百出的广告，甚至利用用户对计算机不了解而修改用户内容，强制启动，强制弹出低质量的甚至具有欺骗性的广告。
一方面，我们免费使用软件，我们理应接受服务者提供广告，另一方面，服务商为了利润，不惜干涉我们对电脑的正常使用。流氓软件和垃圾广告充斥着整个软件市场，在法律尚未完善的情况下在试探伦理与道德的底线。
1. 流氓软件的概念  “流氓软件”是介于病毒和正规软件之间的软件。如果电脑中有流氓软件，可能会出现以下几种情况：用户使用电脑上网时，会有窗口不断跳出；电脑浏览器被莫名修改增加了许多工作条；当用户打开网页时，网页会变成不相干的奇怪画面，甚至是黄色广告。^[百度百科：流氓软件]
 流氓软件有着如下几个特点：
它采用多种社会和技术手段，强行或者秘密安装，并抵制卸载；能强行修改用户软件设置，如浏览器的主页，软件自动启动选项，安全选项；强行弹出广告，或者其他干扰用户、占用系统资源行为；有侵害用户信息和财产安全的潜在因素或者隐患；未经用户许可，或者利用用户疏忽，或者利用用户缺乏相关知识，秘密收集用户个人信息、秘密和隐私；威胁恐吓或误导用户安装其他的产品。 ^[百度百科：流氓软件]
2. 流氓软件的灰色产业链： “流氓软件”的最大商业用途就是散布广告，并形成了整条灰色产业链：企业为增加注册用户、提高访问量或推销产品，向网络广告公司购买广告窗口流量，网络广告公司用自己控制的广告插件程序，在用户电脑中强行弹出广告窗口。 而为了让广告插件神不知鬼不觉地进入用户电脑，大多数时候广告公司是通过联系热门免费共享软件的作者，以每次几分钱的价格把广告程序通过插件的形式捆绑到免费共享软件中，用户在下载安装这些免费共享软件时广告程序也就趁虚而入。 据称，网络广告的计费是按弹出次数进行的，使用“流氓软件”可以在用户根本没有授权的情况下随意弹出广告，提高广告弹出次数，籍此提高广告收益。一个“装机量”大的广告插件公司，凭“流氓软件”月收入在百万元以上。^[百度百科：流氓软件]
3. 用户体验观感 案例1：2345浏览器
在知乎的一篇文章 https://zhuanlan.zhihu.com/p/150785825 中， 2345 浏览器，2345 好压被列入了强烈不建议安装的软件，起因是2345 浏览器会强制改变浏览器主页绑定，有着难删除，难彻底删除，频繁推送广告的特点。
在知乎讨论 最流氓的软件可以流氓到什么程度？ 中有这么一篇回答：
让人哭笑不得的伴随安装
案例二：虚假的套路式广告
来自知乎用户风雨的回答：
4. 垃圾广告 参考知乎提问：如何看待中国互联网垃圾广告问题？ https://www.zhihu.com/question/39396173
大多数人认为垃圾广告严重影响了上网的质量，低俗的，虚假的广告不仅会扭曲青少年儿童等群体，还可能使人受骗上当，净化互联网迫在眉睫。
而另一部分人认为：网站要生存，但这些流量小的网站不受那些大（正常）广告主的青睐，但他们要生存，要挣钱，所以只能有这些低级甚至虚假广告存在。而且在我们日常生活中处处存在着垃圾广告，电线杆，甚至是共享单车上都会有各种广告，单单对互联网，软件上的广告眼红是不公平的。
5. 误导性广告新花样 案例：拼多多 参考文章：令人讨厌的“拼多多” https://zhuanlan.zhihu.com/p/102700604
 没有选择把自己的logo放在显著位置而是将之“隐藏”起来已经说明拼多多“做贼心虚”。
  仔细分析一下这三个广告，其中一个是“签到福利”，意思是在app签到即可获得现金50～100元不等的转账，然而我翻遍了整个APP也没有看到一个“签到”功能。
  拿不存在的功能出来投放广告，这是实打实的欺骗了？
  再看另外两个广告，一个宣传的是充值送话费，另一个宣传的则是“天天领现金”的诱导分享活动，都是非常有技巧地将“最高10/100元，金额以实际为准”的字眼用接近背景色的深色隐藏起来，在两三秒的开屏广告时间内，很难被注意到。
  这种做法不可谓不“鸡贼”，也着实令人讨厌
 个人使用软件体验：像拼多多，抖音，淘宝这样的广告经常出现在某些应用软件启动时，首先这些软件借助虚假的宣传含糊的说明引诱用户点进去，而一旦点击进去，不经过用户同意，后台就自动开始下载拼多多。如果多加注意还好，然而用户经常由于不小心触摸显示屏而“触发了这些扳机”，不小心下载软件。除此之外，广告会被做的非常有欺骗性：比如说广告投屏上会做一个虚假的“关闭”按钮，欺骗用户点进去下载软件，稍不注意或缺乏经验就会中招。
显然着不含欺骗性诱导性的因素，但由于执法难和定法难等因素使得这些“操作”猖狂地进行。
 小结 总的来说，互联网环境还不够成熟，出现了花样百出令人不悦的流氓软件和垃圾广告；很大程度上，用户在去适应他们，就和适应如何对待骚扰电话一样，在我去浏览器上搜索“垃圾广告”，“流氓软件”时，出现非常多的话题是“如何彻底卸载软件”，“如何关闭广告投放”等等，在互联网发达的世界，用户们也自己去营造自己“舒适的冲浪之旅”，与流氓软件，垃圾广告抗衡。
有违背用户需要的软件不可能长期发展，那些曾经喧哗一时的流氓软件也慢慢被时代淘汰，一句话说得好：“时间在检验这一切”，在这个光速发展的互联网世界也是如此。</description>
    </item>
    
    <item>
      <title>Computing By Using Python</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog6/</link>
      <pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog6/</guid>
      <description>Python 编程实验报告 实验目的   用Python求解高数题
 求解一元方程 求导 求积分 求泰勒展开    用Python求解线代题
 求解矩阵方程组 求行列式 求矩阵的逆    实验准备 下载并安装软件 Anaconda3
实验步骤和实验结果 用Python求解高数题 求解一元方程 1.设 f(x) = (1 - x) / (1 + x), 求证 f(f(x)) = x.(参考数分上册课本 Page24 第一题)
代码：
x = Symbol(&#39;x&#39;)def f(x): return (1-x)/(1+x)def g(x): return f(f(x))simplify(g(x) - x) 运行结果与截屏：
2.解 x + 1/x = 0
运行结果与截屏：答案是两个虚数 i 和 -i</description>
    </item>
    
    <item>
      <title>Programming in Pippin CPUSim</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog4/</link>
      <pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog4/</guid>
      <description>实验名称：硬件编程-机器指令编程 学号：19335286 姓名：郑有为  目录  1.实验目标 2. 实验步骤与结果  2.1. 任务一：简单程序 2.2. 任务二：简单循环   3. 实验小结   实验目标   理解冯·诺伊曼计算机的结构
  理解机器指令的构成
  理解机器指令执行周期
  用汇编编写简单程序
   实验步骤与结果 任务一：简单程序 （1）打开网页 [The PIPPIN User’s Guide](slides/The PIPPIN User’s Guide.html) ，然后输入 Program 1：Add 2 number （2）点step after step。观察并回答下面问题： PC，IR 寄存器的作用。 PC全称Program counter程序计数器，用于存放当前程序执行的下一行指令的地址，并会随着时钟信号更新。用于实现程序的顺序执行和条件跳转，循环跳转。 IR全称Instruction Register指针寄存器，存放指令内容，以便于译码器译码识别指令。
ACC 寄存器的全称与作用。 ACC（Accumulator）的全称是累加器。累加器是一个具有特殊用途的寄存器，专门用来存放操作数或运算结果。在CPU执行某种运算前，两个操作数中的一个通常应放在累加器中，运算完成后累加器中便可得到运算结果。
用“LOD #3”指令的执行过程，解释Fetch-Execute周期。 Fetch：取指令过程，CPU根据PC中的地址从存储器RAM中找到对应的指令。 Execute：取出后放入IR，IR的内容经过译码器译码后，译码器发出控制信号使得累加器取等号（进行赋值运算），同时译码器发出控制信号将指令中存储的立即数输入到ALU中，计算结果保留在累加寄存器中，PC改指向当前指令的下一条，指令执行结束。
用“ADD W” 指令的执行过程，解释Fetch-Execute周期。 Fetch：取指令过程，CPU根据PC中的地址从存储器RAM中找到对应的指令。 Execute：取出后放入IR，IR的内容经过译码器译码后，译码器发出控制信号使得累加器取加号（进行加运算），译码器将寄存器ACC中的数据取到ALU中，同时译码器发出控制信号将指令中存储的立即数取出，并通过这段立即数（W的地址）找到内存的相应位置取出数据，取出来的数据经过数据选择器进入ALU，在ALU中，该数据原本ACC的值相加，结果保存在累加寄存器中，PC改指向当前指令的下一条，指令执行结束。</description>
    </item>
    
    <item>
      <title>Pseudocode of Washing Machine</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog5/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog5/</guid>
      <description>项目5：用伪代码描述算法。 介绍“自顶向下，逐步求精”的编程方法；以你观察的洗衣机为案例，用伪代码描述洗衣机洗衣的程序。 “自顶向下”的具体内涵是将复杂、大的问题划分为小问题，找出问题的关键、重点所在，然后用精确的思维定性、定量地去描述问题。而“逐步求精”的具体内涵是是将现实世界的问题经抽象转化为逻辑空间或求解空间的问题。复杂问题经抽象化处理变为相对比较简单的问题。经若干步抽象（精化）处理，最后到求解域中只是比较简单的编程问题。1
假设洗衣机可执行的基本操作如下：
water_in_switch(open_close) // open 打开上水开关，close关闭 water_out_switch(open_close) // open 打开排水开关，close关闭 get_water_volume() //返回洗衣机内部水的高度motor_run(direction) // 电机转动。left左转，right右转，stop停 time_counter() // 返回当前时间计数，以秒为单位halt(returncode) //停机，success 成功 failure 失败 1）伪代码分解“正常洗衣”程序的大步骤。 洗衣机洗衣服时，这些子程序被顺序地一一调用
start_up(); //开机mode_selection(); //模式选择get_water(num_of_mode); //注水soak_clothes(num_of_mode); //浸泡wash_clothes(num_of_mode); //洗衣drain_away_water(); //排水spin_dry(); //甩干power_off(); //关机 2）进一步用基本操作、控制语句（IF、FOR、WHILE等）、变量与表达式，写出每个步骤的伪代码 这台洗衣机有三种洗衣模式1，2，3，分别对应不同的洗衣量。不同模式的注水体积，浸泡时间，洗衣，甩干时间有所不同。
start_up(open_close){}mode_selection(){get num_of_mode;return num_of_mode;}get_water(num_of_mode){switch(num_of_mode){case 1: target_volume_of_water = 2L;case 2: target_volume_of_water = 3L;case 3: target_volume_of_water = 4L;}water_in_switch(open);while(get_water_volume() &amp;lt; target_water_volume);water_in_switch(close);}soak_clothes(num_of_mode){switch(num_of_mode){case 1: target_soak_time = 1min;case 2: target_soak_time = 2min;case 3: target_soak_time = 3min;}init time_counter();while(time_counter() &amp;gt;= target_soak_time);}wash_clothes(num_of_mode){switch(num_of_mode){case 1: target_wash_time = 10min;case 2: target_wash_time = 15min;case 3: target_wash_time = 20min;}init time_counter;while(time_counter() &amp;lt;= target_wash_time){if(time_counter() % 2 == 0)motor_run(left);elsemotor_run(right);}motor_run(stop);}drain_away_water(){water_out_switch(open);while(get_water_volume() &amp;gt; 0);water_out_switch(close);}spin_dry(){switch(num_of_mode){case 1: target_dry_time = 4min;case 2: target_dry_time = 6min;case 3: target_dry_time = 8min;}init time_counter();motor_run(left);while(time_counter() &amp;lt;= target_dry_time);motor_run(stop);}power_off(){halt(success);}  -[1] “自顶向下，逐步求精”的方法</description>
    </item>
    
    <item>
      <title>Experiments On EveryCircuit</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog3/</link>
      <pubDate>Sun, 04 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog3/</guid>
      <description>硬件编程-电路与二进制运算  任务一：门电路的设计与功能验证    In A In B Out     0 0 0   0 1 0   1 0 0   1 1 1    电路图如下：其中电压设置为5伏，电阻为400欧，两个开关分别代表In A和In B
验证如下：
用XOR门作非门 电路如下，异或门一个输入接高电平： 实验验证：  任务二：验证电路 A(B+C) 和 AB+AC 等价 电路搭建及验证：三个开关从上到下依次代表A，B，C
真值表：O1代表A(B+C),02代表AB+AC | A | B | C | O1 | O2 | |:-:|:-:|:-:|:-:|:-:| |0|0|0|0|0| |0|0|1|0|0| |0|1|0|0|0| |0|1|1|0|0| |1|0|0|0|0| |1|0|1|1|1| |1|1|0|1|1| |1|1|1|1|1|</description>
    </item>
    
    <item>
      <title>Game Making - Flappy Bird</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog2/</link>
      <pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog2/</guid>
      <description>笨比飞扬鸟 笨比飞扬鸟简单地模仿了经典游戏Flappy Bird 游戏链接: https://www.construct.net/en/free-online-games/free-game-17945/play (手机端和PC端都可以玩)
视频链接: https://www.bilibili.com/video/BV1S54y1y7P7/
 设计思路   游戏规则
玩家需要通过点击鼠标/屏幕来使小鸟跳起来来避免迎面而来的绿柱子，在玩家不进行操作的情况下，笨比小蓝鸟会因为重力而往下掉。当小鸟撞上绿柱子时，游戏结束。
  界面的设定
我们需要三个界面：游戏启动界面，游戏界面和游戏结束界面。通过游戏启动界面的start按钮，玩家可以进入游戏界面进行游戏，当小鸟撞上绿柱子时界面转入游戏结束界面，游戏结束界面显示玩家本轮游戏的分数，并且玩家可以通过restart按钮重新进入游戏启动界面。
  对象和对象行为
小鸟(bird)可以进行跳跃，否则坠落，具有平台(Platform)属性,需要考虑小鸟的下落速度(和加速度)，还有小鸟跳跃一次的高度。
柱子(上柱子up和下柱子down)需要系统以一定的速率生成，并且能够向左移动，并在出界后自动销毁。其中上下柱子需要同时生成，并具有一样的速率，之间留出的间隔需要合理（保证小鸟能过去）,还需要用到随机生成器来是系统每次生成的柱子高度不同。
计分器(全局变量count)需要在小鸟通过一对柱子后计分，并显示在游戏页面左上方。
其余对象还包括文本显示对象(text)和输入对象(touch),按钮(button)和背景(background),他们都是游戏不可缺的元素。
  事件表
将事件表的事件进行分组有利于我们更清晰地安排事件。
分组包括“界面的跳转”，“小鸟的碰撞”，“障碍物的生成和销毁”，“得分的判定”。(在制作过程中有体现)
   制作过程   收集素材
素材来自张羿九学长！
  基本过程
  先创建一个新的项目   创建了三个背景板和对应的事件表，分别处理不同界面的事件：(下图出现在construct3界面的右侧)   单击右键创建对象，也可以直接将图片拖入场景版中直接创建对象   给对象赋予行为(右键单击对象-添加-行为)，以小鸟为例，需要给他赋予平台，并在左栏中给小鸟的速度等赋值，可参考图片：   构建事件表，可参考下面几张图(有一点乱)：
游戏界面的事件表: 开始界面的事件表: 结束界面的事件表:   最后可以耍小聪明美化一下开始结束界面，点击顶部菜单旁边的三角形预览游戏试玩（记得保存项目）。   小经验
可以先看construct3里的游戏实例(https://editor.construct.net/ 里的demo)，体验一下，刚开始不用担心看不明白或者看不全游戏的对象，事件表等是如何安排的，先有个大致印象。到自己实现小游戏时，对一个功能或逻辑不清楚的时候想想之前看的游戏案例有没有实现，再去翻看找到答案！
     问题思考 “0基础”用户为什么能较好编程制作游戏？例如，使用 Events sheet 和 Script 选择的区别  相对于编程，图形化的游戏设计程序显然能降低设计游戏的门槛，使用construct3或迷你世界设计游戏，设计者无需掌握脚本语言的，底层的技术被封装好，设计者能专注于处理游戏的安排的设计，减少了设计者的工作量。给予我个人的体验，使用construct3做游戏的全过程包括学习案例，参考案例，设计游戏；若使用脚本语言则需要先学习并熟悉脚本语言，才能设计并编写游戏，耗时长成本高。 相比于脚本语言，显然显示成表的事件表具有更高的可读性，设计者无需掌握脚本语言的。  这些平台如何表达游戏世界的事物和行为？ 如同C++的类，可以通过类的数据成员和成员函数来模拟现实世界的事物和这些事物的行为，而这些平台则是通过对象和对象的动作来模拟游戏世界，同时这些平台提供的对象更针对于游戏的设计，比如精灵和子弹等概念。</description>
    </item>
    
    <item>
      <title>Git - The Learning Experience</title>
      <link>https://wondrouswisdomcard.gitee.io/posts/blog1/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://wondrouswisdomcard.gitee.io/posts/blog1/</guid>
      <description>GitNote主要篇 本学习经验来源 Learn Git Branching https://learngitbranching.js.org/?locale=zh_CN  基础篇 git commit 修改了代码库并保存成一个新的提交记录（这个提交记录的内容可以是你对本地项目的改动），把它看作一个节点，它的父亲节点是上一个提交记录 可以加入commit，如 git commit -m &amp;ldquo;A Little Try&amp;rdquo;
git branch 分支名 创建一个新的分支 我想基于这个提交记录以及他的所有父提交进行新的工作 操作方法 git branch 分支名 例如 git branch newImage 创造了一个叫做newImage的新分支 创建之后 输入 git commit 只有master分支前进了，而newImage保持不动，因为此时星号*标注在master上，星号表示当前所在的分支
git checkout 分支名 表示将星号移动到我们要求的分支上
git merge 分支名 表示把我们提到的分支名合并到当前带星号的分支上 注意这个merge会形成一个新的提交，然后当前星号指示的分支指向这个新的提交
git rebase 分支名 我们在我们提到的分支名下建立了新的提交，此时星号指示的分支指向这个新的提交，我们得到一个线性的提交序列，星号分支原来指向的提交没有消失。
 提高篇—在提交树上移动 HEAD 指向你正在其基础上进行工作的提交记录，总是指向当前分支的最近一次提交记录 分离的HEAD就是让其指向某个具体的提交记录而不是分支名 比如只有master分支时，HEAD指向master，master指向提交记录C1（C1是哈希值）可以使用git log来查看提交记录的哈希值 使用 git checkout C1 后，变成了 HEAD 指向C1
相对引用 使用 ^ 向上移动一个提交记录 使用例子 git checkout master^ 使用 ~&amp;lt; num &amp;gt; 向上移动多个提交记录，如 ~3 例子 git checkout~4</description>
    </item>
    
  </channel>
</rss>