# 哈希

## 知识点1、哈希的概念

哈希指将一个在记录的存储位置和它的关键字之间建立一个确定的对应关系，使得每一个字的关键字与结构中唯一一个存储位置相对应。在查找时，我们可以通过对应关系和给定的关键字找到存储的位置。其中的对应关系成为哈希函数。依靠这个思想可以建立哈希表。

*我觉的哈希表的一种作用可能是这样的：一个对象可以通过对应关系找到哈希表的相应位置（一种关键字映射到整数值的对应关系），这个位置可以存储某个数据对应的地址，我们再通过这个地址来找到数据，依次实现“查找”的功能。*

对于哈希函数往往不是一一对应的双函数，往往哈希表的Capacity小于我们数据的总数，哈希函数不可避免地会出现冲突，即不同的关键字通过对应关系得到的位置是相同的，这时我们需要**冲突消解**的策略。

**哈希提供增删查三种操作，并且平均时间复杂度都在$O(1)$**，不支持常数时间查找最大最小值。

## 知识点2、哈希函数的设计

课件上的几个例子：

1、关键字：分数（分子+分母）

策略：大质数（例如：f = 分子 + 分母 * 大质数）

2、关键字：字符串

策略：把字符串每一个字符的ASCII码对应数值相加

问题：会出现“oi”和“io”冲突的现象

修正1：在每一个字符在相加前乘以一个权值，权值由字符位置决定，我们还可以利用如下二项式形式$p(x)=c_0x^{n-1} + c_1x^{n-2}+...+c_{n-1}$，其中x表示我们权值的参数，c表示对应位的字符ASCII值。
实现伪代码：

    hash_value = 大质数(x) * hash_value + str[k];

*我发现一个事情，就是我们老师讲的哈希好像有两层，一层是先将非整数类型的对象通过一层函数转化成一个整数（32位的int），然后再通过一个常数转常数的哈希函数将这个大的数字转换成哈希表的对应位置。需要注意的是，在这种情况下我们在第二层哈希时（即与哈希表相关时）才需要冲突消解。*

在老师的这种框架下，第二层哈希函数就很简单，非常简单，就是**拿哈希表的Size来取模**，为了取模运算提速（移位操作取代取模运算），哈希表的Size往往设置成2^m。

在上一层考虑下，单纯地取模（即取后m位二进制数）有时候会出现数据堆积的情况，第二层哈希也可以利用取模的原理，但做一些花哨的操作（通过位操作运算符）：比如取前k位和后m-k位，或者**挑选特定的二进制来拼接成一个m位的数**（参考我们哈希表的实验题）。

更花哨一点的：先乘以一个常数，再取中间的m位（取中间的m位实现：比如右移(32-m)/2再取后m位）

    return ((Constant*k)>>((32-m)/2)) & ((1<<m)-1);

## 知识点3、冲突消解1-分离链接法

实现：哈希表的每一个元素接一个链表

装填因子： $\lambda = \frac nm$，n是载入的数量，m是哈希表的Size，如果装填因子过大，访问的时间会增加到$O(\lambda)$，装填因子一般都大于1。

缺点：额外的空间消耗（指针）

可改进：把每一个链表做成AVL树（真是闲着没事干）

## 知识点4、冲突消解2-开放地址法

基本原理：如果有冲突发生，尝试选择另外的单元，直到找出空的单元为止，一般来说装填因子应该要低于0.5.

### 线性探测法

插入原理：如果有冲突发生，尝试选择下一个的单元，直到找出空的单元为止。

查询原理：不对应就一直往后查，直到查到空单元

删除原理：不能直接删除，只能对其进行标记，再重新哈希所有元素前这个空间点是无法被利用的。

线性探测法不好的地方：容易出现一次集群，就随着插入的增加，很多都聚在一起，而集群越长，插入和查找的时间就会增加，冲突的代价也就越高。

时间复杂度分析：与装填因子$\lambda$有关**平均成功查找次数**$\frac12(1+\frac1{1-\lambda})$，**平均插入/平均失败查找次数**$\frac12(1+\frac1{(1-\lambda)^2})$。（怎么算出来的你别管了）

### 平方探测法

为了避免集群产生，也就是为了让插入的数据再哈希表中分布的更均匀，我们使用二次探测，当冲突发生时，冲突函数$F(i)=i^2$，意思是当第i个位置被占了以后，我们找的下一个位置是当前位置+$i^2$。

冲突函数也可以定义为$F(i)=(i+i^2)/2$，**i表示的是在这一个插入过程中碰撞了几次**（是吗），$bin_{k+1} = (initial + F(k+1))\% M$，有$bin_{k+1} = bin_k + (k+1)$，即一旦冲突，先加一，再冲突，在这个新冲突的位置的基础上加二...加三，加四...

我们可以记录并计算其装填因子和平均探测数。

当要调整哈希表(2^m)本身的大小时，我们的策略是取更多位，扩大m,然后再将所有哈希过的对象重新在哈希一编，（由于m增大了，哈希得到的结果与之前的不同），扩大哈希表能够降低装填引子和平均探测数。

删除同样采取**慵懒删除**的方法，和线性探测的删除相同。

时间复杂度分析：与装填因子$\lambda$有关**平均成功查找次数**$\ln(1/(1-\lambda))/\lambda$，**平均插入/平均失败查找次数**$1/(1-\lambda)$，（怎么算出来的你别管了）效果好于线性探测。

一个定理：如果使用平方探测，且表的大小是一个素数，那么当表至少还有一般是空的的时候，总能插入一个新的元素。

### 二次哈希

$F(i) = i * hash_2(X)$
我觉得是每次冲突后加的值，对于一个对象来说，是固定的，即每次找不到就右移F(i)个格子？

一种取法：Consider a hash table with M = 64 bins. Given a 12-bit unsigned number, take **the lowest 6 bits as the primary hash function to get the bin number**, **and the highest 6 bits as the secondary hash function to get the jump size**.

注：jump还要**或1**来保证他是奇数，来与M互质

另一种取法：利用一个大质数

    jump = hash_M(x.hash()*5322343959,M) | 1;
    bin = (initial+k*jump) & (M-1);

时间复杂度分析：与装填因子$\lambda$有关**平均成功查找次数**$\ln(1/(1-\lambda))/\lambda$，**平均插入/平均失败查找次数**$1/(1-\lambda)$，（怎么算出来的你别管了）效果好于线性探测，和二次哈希的效果是一样的。

### 收尾

删除操作的实现：使用一个标记三种状态：使用，未使用，删去

一般来说使用二次哈希已经很OK啦

### ASL计算（重要）

计算成功时平均查找长度和失败时平均查找长度。

对于具体的哈希过程，ASL成功和ASL失败的值要按照实际情况来进行统计。

具体值找出在当前状态下，所有关键字值/哈希值的平均查找时间再求平均。

成功：
成功查找次数 = 冲突次数 + 1
所有数据给出的**关键字值**的平均查找时间再求平均。

失败：
所有可能的**哈希值**的平均失败查找时间再求平均。
