# Lecture15 哈夫曼编码

## 知识点1、最优二元树

在具有$k$个叶子结点且各个叶子结点分别被赋予非负权值$p_i$的二元树中，带有最小带权外部通路总长度着成为相对于权值序列的最优二元树，通常不唯一。

## 知识点2、哈夫曼算法

算法维护一个非递减的权值序列，每一趟从序列中取出最靠前的两个权值，构造他们的父亲结点（父亲权值为两个子权值之和），并向序列增加这个权值。持续迭代该过程直至序列中只剩下一个元素。

**时间复杂度：可以期望达到$O(k \log k)$。**

哈夫曼树的特征：构造出来的哈夫曼树是一类最优二元树，它是一棵正则树，底层叶子必定有最小权值。

## 知识点3、不等长编码

此处的编码：使用二进制符号为源信息码进行编码。有编码长度，码元等概念。

等长编码：译码时依靠编码长度对码流进行分组，每组有编码长度个码元。对照译码表翻译成源码。N个源码符号的编码总长度是$N*编码长度$，效率较低。

不等长编码：也称为压缩编码，通过统计编码平均长度来估计编码总长度，需要符合**无前缀**的约束（为确保编码的唯一性）。

**前缀编码**：前缀编码是一种无前缀的约束编码方式，他要求在**码表中不能有任何源码的编码是其他源码的编码的前缀。**

## 知识点4、二元编码树

**二元编码树是一颗用叶子结点标记源码的二叉树**，我们规定指向结点的左儿子的树枝标记为0，右儿子的树枝标记为1。

编码过程：从根结点到某个叶子结点的道路上树枝的二进制编码序列，顺序从根开始伸展，**达到叶子结点后码流的下一位回到树根重新开始解释**。（上述过程构造的编码体系是一类前缀编码）

## 知识点5、编码总长度的计算问题

设有k个描述源码的叶子结点，每个源码的**出现频度**为$p_i$，我们将出现频度作为叶子结点的权值，叶子的编码长度是叶子在树中的**深度**，N个源码符号的编码总长度为$M = N \times \sum_{i=0}^k p_il_i = N \times M(T)$，其中M(T)为**二元编码树外部通路总长度**，也是全部叶子编码长度的统计平均值。

我们可以得到 哈夫曼编码是关于上述源码符号集的最短二元前缀码。

## 知识点6、哈夫曼编码的实现

根据哈夫曼树二元正则树的特性，n个叶子结点的哈夫曼树必有2n-1个结点，故可以使用一个2n-1大小的数组来存储。

结点的数据结构： 【权，父母结点下标，左二子下标，右儿子下标】

获取哈夫曼编码两种方式：
    1、所有找到叶子结点（儿子为空的结点），逆向遍历再处理得到对应字符的哈夫曼编码。
    2、从根深度遍历，我们利用栈的内容来得到每个叶子结点的哈夫曼编码序列。

